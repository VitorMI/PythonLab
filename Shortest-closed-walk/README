# Shortest-closed-walk

# Código desenvolvido durante a aula 18 da cadeira Teoria dos Grafos - Ufcg

## Chinese Postman Problem 

# Alguns problemas como o Chinese Postman Problem demandam a definição de um passeio fechado de menor custo 
# que inicia e termina em um mesmo vértice e percorre todas as arestas de um grafo. 
# Não se trata da definição de um circuito de Euler, visto que arestas podem ser repetidas. 
# No entanto, algoritmos para encontrar um circuito de Euler são comumente utilizados para auxiliar na definição deste passeio.

# Implemente a função shortest_closed_walk que recebe como entrada um grafo ponderado não-direcionado G 
# e um vértice init deste grafo e retorna um passeio fechado de menor custo que passa por todas as arestas, 
# iniciando e terminando em init. Assuma que G é uma instância da classe Graph.

# Para implementar esta função, sugerimos utilizar a seguinte heurística:

# Crie uma cópia de G como um multigrafo:
M = nx.Multigraph(G)

# Se (x,y) é uma aresta de G, então M terá aresta (x,y,0), onde 0 é o identificador (key) da aresta.
# Seja odd_nodes uma lista com os vértices de grau ímpar de M. Lembrando que em todo grafo, 
# a quantidade de vértices de grau ímpar é um número par.

while odd_nodes:
    # Encontre dois vértices x e y em odd_nodes cuja distância entre eles seja a menor possível
    # (Dica: use a função shortest_path_length para calcular a distância entre dois os vértices);
    x, y = find_closest_pair(odd_nodes, M)

    # Para cada aresta (u,v,0) no caminho entre x e y, adicione uma nova aresta (u,v,key) em M com o mesmo peso.
    # Desta forma x e y passarão a ter grau par. O seguinte trecho pode ser usado para adicionar a aresta,
    # com o mesmo peso da original.
    for u, v in get_path_between(x, y, M):
        M.add_edge(u, v, key)
        M[u][v][key]['weight'] = g.get_edge_data(u, v, 0)['weight']
        key += 1

    # Remova x e y de odd_nodes.
    odd_nodes.remove(x)
    odd_nodes.remove(y)

# No grafo M resultante, que será um grafo par, execute a função eulerian_circuit 
# passando init como parâmetro e retorne o circuito calculado.
eulerian_circuit = nx.eulerian_circuit(M, init)
return eulerian_circuit
